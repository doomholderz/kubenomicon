# Application Vulnerability
The "code security" is the code of the application being deployed into the cluster. Fundamentally this is not really a "Kubernetes" specific attack path. Attacking this layer is generally performing a web application penetration test in an application hosted in a Kubernetes cluster. From this layer, you're looking to identify any sort of web application vulnerability that will allow you to get a shell on within the application (or possibly [SSRF](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)).

Typically _initial access_ into a Kubernetes cluster from an external perspective relies on some sort of injection attack that allows an attacker to get a foothold. Getting a shell in an web application running in a Kubernetes cluster will drop you inside the Pod running the container the application is hosted in.



# Defending 

All of the standard application security best practices should be followed to ensure your applications are not vulnerable to these exploits in the first place. This field is generally referred to as application security. At a very high level, ensure that applications are not vulnerable to common attacks outline in the [OWASP Top 10](https://cheatsheetseries.owasp.org/IndexTopTen.html).

1. **Pre-commit security**
    - Perform continuous threat-modeling
    - Enforce Peer code reviews
    - IDE security plugins
    - Pre-commit hooks
2. **Commit Security**
    - Perform static application security testing (SAST)
    - Perform security unit testing
    - Understand supply chain/dependency risks
3. **Pre-Production**
    - Perform web application security testing


## Scanning Container Images
Threat actors rely on you to pull the image and deploy it in your cluster or to even just run it. The aim for them would be to then use its backdoor to break out and hope to get into the wider cluster causing havoc.

A strategy to mitigate a compromised image in your registry would be to scan your images before deploying them into your environment. This can be achieved by a scan of the image using Trivy. 

> Note: Trivy scans for known vulnerabilities, it is not used to perform any time of SAST scanning.

Trivy detects known vulnerabilities and outputs to the screen the total number of vulnerabilities, scored from `LOW`, `MEDIUM`, `HIGH` and `CRITICAL`.

First, install theÂ `trivy`Â vulnerability scanner onÂ host â€” refer to the aqua trivy documentation: [https://aquasecurity.github.io/trivy-repo/](https://aquasecurity.github.io/trivy-repo/deb/public.key).

```bash
# Update Repo and Install trivy
apt-get update
apt-get install 

```

Next, run the command `trivy image <image-name:name>` or `trivy image --input /path/to/<file-name>.tar`

Note: If youâ€™re scanning a tar file, be sure to have it downloaded locally such that you could reference it.

![](../images/trivy-image-scan.png)

In the Figure above we scan the kube-apiservers image.

![](../images/trivy-tar-scan.png)

In the Figure above we scan a tar file, from an alpine image we found.

You could also scan an unpacked container image filesystem.

```bash
First export the image as an unpacked container filesystem:
`docker export $(docker create alpine:3.10.2) | tar -C /tmp/rootfs -xvf -`

Then run the scan

`trivy fs /tmp/rootfs`
```

Vulnerability scanning tools are among other defensive mechanisms, would allow one to have visibility into the exact severity of the vulnerability that a malicious image may have, such as backdoors or unrelated malicious packages thus allowing one to understand deeper the latest nuanced attack vectors threat actors are utilising.

As a bonus Iâ€™ll share a very basic shell script that can be stored within the bash.rc file to make scanning even easier for your team.
ðŸ˜‰
As a pre-requisite, you need to have trivy installed as a package -- refer back to the docs referenced above.

```bash
`#!/bin/bash`

# Presenting the options to the admin on what they would like to scan
echo "1. Image"
echo "2. Tar File"
echo "3. Repsoitory"
echo "4. File system"
read -p "Select one of the 4 options: " op
# Based on the option the user has chosen. We present then with the prompt to provide the parameter to what they would like to scan.i
if [ $op -eq 1 ]
then
read -p "Enter image name: " image
trivy image $image
elif [ $op -eq 2 ]
then
read -p "Enter path to tar file: " tar
trivy image -input $tar
elif [ $op -eq 3 ]
then
read -p "Enter repository URL: " repo
trivy repo $repo
elif [ $op -eq 4 ]
then
read -p "Enter path to unpacked container image filesystem: " fs
trivy fs $fs
fi`
```
